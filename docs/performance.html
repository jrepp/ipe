<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPE Predicate Execution Performance Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 50%, rgba(255,255,255,0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .subtitle {
            font-size: 0.9em;
            opacity: 0.9;
            font-weight: 400;
            position: relative;
        }

        .dashboard {
            padding: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.1);
            backdrop-filter: blur(10px);
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 0.9em;
            color: #555;
        }

        select, button {
            padding: 8px 12px;
            border: 1.5px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        select {
            background: rgba(255, 255, 255, 0.9);
        }

        select:hover {
            border-color: #667eea;
            background: white;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.25);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.95) 100%);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .chart-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 40px rgba(102, 126, 234, 0.25);
        }

        .chart-container:hover::before {
            opacity: 1;
        }

        .chart-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .chart {
            width: 100%;
            height: 400px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(118, 75, 162, 0.08) 100%);
            color: #4a5568;
            padding: 12px 16px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.12);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.03) 0%, transparent 70%);
            pointer-events: none;
        }

        .stat-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            border-color: rgba(102, 126, 234, 0.25);
        }

        .stat-value {
            font-size: 1.6em;
            font-weight: 600;
            margin: 4px 0;
            position: relative;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.75em;
            opacity: 0.75;
            font-weight: 500;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            color: #718096;
        }

        .tooltip {
            position: absolute;
            padding: 14px 18px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            color: white;
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.85em;
            max-width: 320px;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(102, 126, 234, 0.95);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .axis-label {
            font-size: 1.2em;
            fill: #666;
            font-weight: 600;
        }

        /* Make all SVG text larger */
        svg text {
            font-size: 13px !important;
            fill: #444;
        }

        svg .tick text {
            font-size: 12px !important;
        }

        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.5em;
            color: #667eea;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes warpIn {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(30px);
            }
            60% {
                transform: scale(1.02) translateY(-5px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .chart-container {
            animation: warpIn 0.7s cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
        }

        .chart-container svg {
            animation: fadeInUp 0.5s ease-out 0.3s backwards;
        }

        .chart-container:nth-child(1) { animation-delay: 0.1s; }
        .chart-container:nth-child(2) { animation-delay: 0.2s; }
        .chart-container:nth-child(3) { animation-delay: 0.3s; }
        .chart-container:nth-child(4) { animation-delay: 0.4s; }
        .chart-container:nth-child(5) { animation-delay: 0.5s; }
        .chart-container:nth-child(6) { animation-delay: 0.6s; }
        .chart-container:nth-child(7) { animation-delay: 0.7s; }

        .stat-card {
            animation: fadeInUp 0.5s ease-out backwards;
        }

        .stat-card:nth-child(1) { animation-delay: 0.05s; }
        .stat-card:nth-child(2) { animation-delay: 0.1s; }
        .stat-card:nth-child(3) { animation-delay: 0.15s; }
        .stat-card:nth-child(4) { animation-delay: 0.2s; }
        .stat-card:nth-child(5) { animation-delay: 0.25s; }

        .error {
            text-align: center;
            padding: 50px;
            color: #dc3545;
            font-size: 1.2em;
        }

        /* Tablet styles (768px - 1024px) */
        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .container {
                margin: 10px;
                border-radius: 15px;
            }

            .dashboard {
                padding: 20px;
            }
        }

        /* Mobile landscape and small tablets (480px - 768px) */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                margin: 0;
                border-radius: 10px;
            }

            header {
                padding: 15px 20px;
            }

            h1 {
                font-size: 1.4em;
                letter-spacing: -0.3px;
            }

            .subtitle {
                font-size: 0.8em;
            }

            .dashboard {
                padding: 15px;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 12px;
                margin-bottom: 20px;
            }

            .stat-card {
                padding: 10px 12px;
            }

            .stat-value {
                font-size: 1.3em;
            }

            .stat-label {
                font-size: 0.7em;
            }

            .grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .chart-container {
                padding: 15px;
                margin-bottom: 20px;
            }

            .chart-title {
                font-size: 1.1em;
                margin-bottom: 10px;
            }

            .chart {
                height: 350px;
            }

            /* Reduce margins for mobile charts */
            svg text {
                font-size: 10px !important;
            }

            .controls {
                flex-direction: column;
                padding: 12px 15px;
                gap: 10px;
            }
        }

        /* Mobile portrait (< 480px) */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                border-radius: 8px;
            }

            header {
                padding: 12px 15px;
            }

            h1 {
                font-size: 1.2em;
                margin-bottom: 3px;
            }

            .subtitle {
                font-size: 0.75em;
            }

            .dashboard {
                padding: 10px;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 15px;
            }

            .stat-card {
                padding: 8px 10px;
            }

            .stat-value {
                font-size: 1.2em;
            }

            .stat-label {
                font-size: 0.65em;
            }

            .grid {
                gap: 15px;
                margin-bottom: 15px;
            }

            .chart-container {
                padding: 12px;
                margin-bottom: 15px;
            }

            .chart-title {
                font-size: 1em;
                margin-bottom: 8px;
                padding-bottom: 6px;
            }

            .chart {
                height: 300px;
                overflow-x: auto;
            }

            /* Make horizontal bar charts scrollable on mobile */
            .chart svg {
                min-width: 400px;
            }

            svg text {
                font-size: 9px !important;
            }

            svg .tick text {
                font-size: 8px !important;
            }

            button {
                padding: 10px 15px;
                font-size: 0.9em;
                width: 100%;
            }

            .controls {
                padding: 10px;
                gap: 8px;
            }

            .control-group label {
                font-size: 0.85em;
            }

            select {
                padding: 8px 10px;
                font-size: 0.85em;
                width: 100%;
            }

            /* Touch-friendly tooltips */
            .tooltip {
                max-width: 250px;
                font-size: 0.8em;
                padding: 10px 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🚀 IPE Predicate Execution Performance Dashboard</h1>
            <div class="subtitle">Interactive Performance Analysis & Visualization</div>
            <a href="index.html" style="display: inline-block; margin-top: 15px; padding: 6px 16px; background: rgba(255,255,255,0.15); color: white; text-decoration: none; border-radius: 6px; font-weight: 500; font-size: 0.85em; transition: all 0.3s; border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(10px); position: relative;">← Back to Home</a>
        </header>

        <div class="dashboard">
            <div id="loading" class="loading">Loading performance data...</div>
            <div id="error" class="error" style="display: none;"></div>
            <div id="content" style="display: none;">
                <!-- Summary Stats -->
                <div class="stats-grid" id="stats-grid"></div>

                <!-- Export Button -->
                <div style="text-align: right; margin-bottom: 20px;">
                    <button onclick="exportData()" style="padding: 10px 20px; background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">📥 Export Data</button>
                </div>

                <!-- Charts Grid -->
                <div class="grid">
                    <div class="chart-container">
                        <div class="chart-title">📊 p50 Latency (All Workloads)</div>
                        <div id="p50-chart" class="chart"></div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-title">📈 p95 Latency (All Workloads)</div>
                        <div id="p95-chart" class="chart"></div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-title">🎯 p99 Latency (All Workloads)</div>
                        <div id="p99-chart" class="chart"></div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-title">⚡ Throughput (All Workloads)</div>
                        <div id="throughput-chart" class="chart"></div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-title">💾 JIT Cache Hit Rate</div>
                        <div id="cache-chart" class="chart"></div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-title">⚖️ JIT vs Interpreter Speedup</div>
                        <div id="speedup-chart" class="chart"></div>
                    </div>

                    <div class="chart-container full-width">
                        <div class="chart-title">📈 Performance Trends Over Time</div>
                        <div id="trends-chart" class="chart" style="height: 500px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global data storage
        let perfData = null;
        let filteredData = null;
        let historyData = null;

        // Color schemes - refined palette in blue/purple space
        const colors = {
            interpreter: '#7c3aed',  // Refined violet
            jit: '#4f46e5',          // Refined indigo
            cache: '#8b5cf6',        // Soft purple
            accent: '#6366f1'        // Subtle blue-violet
        };

        // Load data
        async function loadData() {
            try {
                // Check if we're on file:// protocol
                if (window.location.protocol === 'file:') {
                    throw new Error('file:// protocol detected. Please use a local web server to view this page.');
                }

                // Load both perftest results and historical benchmark data
                const [perfResponse, historyResponse] = await Promise.all([
                    fetch('perftest-results.json'),
                    fetch('benchmark-history.json')
                ]);

                if (!perfResponse.ok) throw new Error('Failed to load perftest-results.json');

                perfData = await perfResponse.json();

                // Initialize filteredData with all results
                filteredData = perfData.results;

                // Load history data (optional - may not exist yet)
                if (historyResponse.ok) {
                    historyData = await historyResponse.json();
                }

                updateSummaryStats();

                // Show content BEFORE drawing charts so D3.js can measure dimensions
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                // Draw charts after content is visible
                setTimeout(() => {
                    drawAllCharts();
                }, 100);
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';

                let errorMsg = `Error loading data: ${error.message}`;

                if (window.location.protocol === 'file:') {
                    errorMsg += `

                    <div style="margin-top: 20px; padding: 20px; background: #fff3cd; border-radius: 8px; text-align: left;">
                        <strong>🚫 Direct file access is not supported</strong><br><br>
                        Due to browser security restrictions, this page cannot load data via file:// protocol.<br><br>
                        <strong>Please use one of these methods:</strong><br><br>
                        <strong>Option 1:</strong> Python HTTP Server<br>
                        <code style="background: #2d2d2d; color: #f8f8f2; padding: 10px; display: block; border-radius: 5px; margin: 10px 0;">
                        cd docs && python3 -m http.server 8080<br>
                        # Then open http://localhost:8080/performance.html
                        </code><br>

                        <strong>Option 2:</strong> Just command<br>
                        <code style="background: #2d2d2d; color: #f8f8f2; padding: 10px; display: block; border-radius: 5px; margin: 10px 0;">
                        just test-pages-headed
                        </code><br>

                        <strong>Option 3:</strong> View on GitHub Pages<br>
                        Deploy this to GitHub Pages and access via https://
                    </div>`;
                } else {
                    errorMsg += ' Make sure perftest-results.json exists in the same directory.';
                }

                document.getElementById('error').innerHTML = errorMsg;
            }
        }

        function drawAllCharts() {
            drawMetricChart('p50', 'p50-chart');
            drawMetricChart('p95', 'p95-chart');
            drawMetricChart('p99', 'p99-chart');
            drawThroughputChart();
            drawCacheChart();
            drawSpeedupChart();
            drawTrendsChart();
        }

        function updateSummaryStats() {
            const stats = calculateSummaryStats();
            const statsGrid = document.getElementById('stats-grid');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Tests</div>
                    <div class="stat-value">${perfData.total_tests}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Duration</div>
                    <div class="stat-value">${perfData.total_duration_secs.toFixed(1)}s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg Throughput</div>
                    <div class="stat-value">${stats.avgThroughput.toFixed(0)}</div>
                    <div class="stat-label">ops/sec</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Best p99</div>
                    <div class="stat-value">${stats.bestP99.toFixed(2)}</div>
                    <div class="stat-label">µs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">JIT Speedup</div>
                    <div class="stat-value">${stats.jitSpeedup.toFixed(1)}x</div>
                </div>
            `;
        }

        function calculateSummaryStats() {
            const avgThroughput = d3.mean(perfData.results, d => d.statistics.throughput) || 0;
            const bestP99 = d3.min(perfData.results, d => d.statistics.p99) || 0;

            const interpreterResults = perfData.results.filter(r => r.executor === 'interpreter');
            const jitResults = perfData.results.filter(r => r.executor === 'jit');

            let jitSpeedup = 1;
            if (interpreterResults.length > 0 && jitResults.length > 0) {
                const avgInterpreter = d3.mean(interpreterResults, d => d.statistics.throughput);
                const avgJit = d3.mean(jitResults, d => d.statistics.throughput);
                jitSpeedup = avgJit / avgInterpreter;
            }

            return { avgThroughput, bestP99, jitSpeedup };
        }

        function drawMetricChart(metric, chartId) {
            const container = d3.select(`#${chartId}`);
            container.selectAll('*').remove();

            // Group data by workload+executor and sort by value (highest to lowest)
            const groupedData = perfData.results
                .map(d => ({
                    label: `${d.workload.replace(/_/g, ' ')} (${d.executor})`,
                    executor: d.executor,
                    value: d.statistics[metric],
                    data: d
                }))
                .sort((a, b) => b.value - a.value);

            const margin = {top: 20, right: 80, bottom: 50, left: 280};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = Math.max(400, groupedData.length * 40);

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const x = d3.scaleLinear()
                .domain([0, d3.max(groupedData, d => d.value) * 1.1])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(groupedData.map(d => d.label))
                .range([0, height])
                .padding(0.2);

            // Bars
            svg.selectAll('.bar')
                .data(groupedData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.label))
                .attr('width', d => x(d.value))
                .attr('height', y.bandwidth())
                .attr('fill', d => d.executor === 'jit' ? colors.jit : colors.interpreter)
                .attr('rx', 4)
                .attr('opacity', 0.85)
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke', '#333').attr('stroke-width', 2);
                    showTooltip(event, d.data);
                })
                .on('mouseout', function() {
                    d3.select(this).attr('opacity', 0.85).attr('stroke', 'none');
                    hideTooltip();
                });

            // Value labels on bars
            svg.selectAll('.value-label')
                .data(groupedData)
                .enter().append('text')
                .attr('class', 'value-label')
                .attr('x', d => x(d.value) + 5)
                .attr('y', d => y(d.label) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#2d3748')
                .text(d => `${d.value.toFixed(2)} µs`);

            // Y axis (labels)
            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '13px')
                .style('font-weight', '500');

            // X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .style('text-anchor', 'middle')
                .style('font-size', '13px')
                .style('font-weight', '600')
                .style('fill', '#4a5568')
                .text(`${metric.toUpperCase()} (µs)`);
        }

        function drawThroughputChart() {
            const container = d3.select('#throughput-chart');
            container.selectAll('*').remove();

            // Group data and sort by throughput (highest to lowest)
            const groupedData = perfData.results
                .map(d => ({
                    label: `${d.workload.replace(/_/g, ' ')} (${d.executor})`,
                    executor: d.executor,
                    value: d.statistics.throughput,
                    data: d
                }))
                .sort((a, b) => b.value - a.value);

            const margin = {top: 20, right: 100, bottom: 50, left: 280};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = Math.max(400, groupedData.length * 40);

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const x = d3.scaleLinear()
                .domain([0, d3.max(groupedData, d => d.value) * 1.1])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(groupedData.map(d => d.label))
                .range([0, height])
                .padding(0.2);

            // Bars
            svg.selectAll('.bar')
                .data(groupedData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.label))
                .attr('width', d => x(d.value))
                .attr('height', y.bandwidth())
                .attr('fill', d => d.executor === 'jit' ? colors.jit : colors.interpreter)
                .attr('rx', 4)
                .attr('opacity', 0.85)
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke', '#333').attr('stroke-width', 2);
                    showTooltip(event, d.data, 'throughput');
                })
                .on('mouseout', function() {
                    d3.select(this).attr('opacity', 0.85).attr('stroke', 'none');
                    hideTooltip();
                });

            // Value labels on bars
            svg.selectAll('.value-label')
                .data(groupedData)
                .enter().append('text')
                .attr('class', 'value-label')
                .attr('x', d => x(d.value) + 5)
                .attr('y', d => y(d.label) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#2d3748')
                .text(d => {
                    const val = d.value;
                    if (val >= 1000000) return `${(val / 1000000).toFixed(1)}M ops/sec`;
                    if (val >= 1000) return `${(val / 1000).toFixed(1)}K ops/sec`;
                    return `${val.toFixed(0)} ops/sec`;
                });

            // Y axis (labels)
            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '13px')
                .style('font-weight', '500');

            // X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d3.format('.2s')))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .style('text-anchor', 'middle')
                .style('font-size', '13px')
                .style('font-weight', '600')
                .style('fill', '#4a5568')
                .text('Throughput (ops/sec)');
        }

        function drawDistributionChart() {
            const container = d3.select('#distribution-chart');
            container.selectAll('*').remove();

            const margin = {top: 20, right: 30, bottom: 50, left: 60};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Box plot data
            const boxData = filteredData.map(d => ({
                name: d.workload,
                executor: d.executor,
                min: d.statistics.min,
                q25: d.statistics.p50 - (d.statistics.p50 - d.statistics.min) / 2,
                median: d.statistics.p50,
                q75: d.statistics.p95,
                max: d.statistics.max
            }));

            const x = d3.scaleBand()
                .domain(boxData.map(d => d.name + '-' + d.executor))
                .range([0, width])
                .padding(0.2);

            const y = d3.scaleLinear()
                .domain([0, d3.max(boxData, d => d.max)])
                .nice()
                .range([height, 0]);

            // Draw box plots
            boxData.forEach(d => {
                const xPos = x(d.name + '-' + d.executor);
                const boxWidth = x.bandwidth();

                const color = d.executor === 'jit' ? colors.jit : colors.interpreter;

                // Vertical line (whiskers)
                svg.append('line')
                    .attr('x1', xPos + boxWidth/2)
                    .attr('x2', xPos + boxWidth/2)
                    .attr('y1', y(d.min))
                    .attr('y2', y(d.max))
                    .attr('stroke', color)
                    .attr('stroke-width', 2);

                // Box
                svg.append('rect')
                    .attr('x', xPos)
                    .attr('y', y(d.q75))
                    .attr('width', boxWidth)
                    .attr('height', y(d.q25) - y(d.q75))
                    .attr('fill', color)
                    .attr('opacity', 0.6);

                // Median line
                svg.append('line')
                    .attr('x1', xPos)
                    .attr('x2', xPos + boxWidth)
                    .attr('y1', y(d.median))
                    .attr('y2', y(d.median))
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 3);
            });

            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => {
                    const parts = d.split('-');
                    return parts[0].substring(0, 10);
                }))
                .selectAll('text')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .style('font-size', '10px');

            svg.append('g')
                .call(d3.axisLeft(y));

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Latency (µs)');
        }

        function drawCacheChart() {
            const container = d3.select('#cache-chart');
            container.selectAll('*').remove();

            const jitData = filteredData.filter(d => d.jit_statistics);

            if (jitData.length === 0) {
                container.append('div')
                    .style('padding', '50px')
                    .style('text-align', 'center')
                    .style('color', '#999')
                    .text('No JIT data available');
                return;
            }

            const width = container.node().getBoundingClientRect().width;
            const height = 400;
            const radius = Math.min(width, height) / 2 - 40;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width/2},${height/2})`);

            const avgCacheHitRate = d3.mean(jitData, d => d.jit_statistics.cache_hit_rate);
            const avgCacheMissRate = 100 - avgCacheHitRate;

            const data = [
                { label: 'Cache Hits', value: avgCacheHitRate },
                { label: 'Cache Misses', value: avgCacheMissRate }
            ];

            const pie = d3.pie().value(d => d.value);
            const arc = d3.arc().innerRadius(radius * 0.5).outerRadius(radius);

            const colors_cache = [colors.jit, colors.cache];

            svg.selectAll('path')
                .data(pie(data))
                .enter().append('path')
                .attr('d', arc)
                .attr('fill', (d, i) => colors_cache[i])
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('d', d3.arc().innerRadius(radius * 0.5).outerRadius(radius * 1.1));
                    showTooltip(event, d.data, 'cache');
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('d', arc);
                    hideTooltip();
                });

            // Center text
            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '-0.5em')
                .style('font-size', '2em')
                .style('font-weight', 'bold')
                .style('fill', colors.jit)
                .text(`${avgCacheHitRate.toFixed(1)}%`);

            svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '1.5em')
                .style('font-size', '1em')
                .style('fill', '#666')
                .text('Cache Hit Rate');
        }

        function drawHeatmap() {
            const container = d3.select('#heatmap-chart');
            container.selectAll('*').remove();

            const margin = {top: 30, right: 100, bottom: 100, left: 100};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const metrics = ['min', 'p50', 'p95', 'p99', 'max'];
            const tests = filteredData.map(d => d.name);

            const x = d3.scaleBand()
                .domain(metrics)
                .range([0, width])
                .padding(0.05);

            const y = d3.scaleBand()
                .domain(tests)
                .range([0, height])
                .padding(0.05);

            // Normalize data for color scale
            const allValues = filteredData.flatMap(d =>
                metrics.map(m => d.statistics[m])
            );

            const colorScale = d3.scaleSequential()
                .domain([d3.min(allValues), d3.max(allValues)])
                .interpolator(d3.interpolateViridis);

            // Draw cells
            filteredData.forEach(test => {
                metrics.forEach(metric => {
                    svg.append('rect')
                        .attr('x', x(metric))
                        .attr('y', y(test.name))
                        .attr('width', x.bandwidth())
                        .attr('height', y.bandwidth())
                        .attr('fill', colorScale(test.statistics[metric]))
                        .on('mouseover', function(event) {
                            showTooltip(event, {
                                test: test.name,
                                metric: metric,
                                value: test.statistics[metric].toFixed(2)
                            }, 'heatmap');
                        })
                        .on('mouseout', hideTooltip);

                    // Add text
                    svg.append('text')
                        .attr('x', x(metric) + x.bandwidth() / 2)
                        .attr('y', y(test.name) + y.bandwidth() / 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('fill', test.statistics[metric] < d3.median(allValues) ? 'white' : 'black')
                        .style('font-size', '10px')
                        .text(test.statistics[metric].toFixed(1));
                });
            });

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '10px');

            // Color legend
            const legendWidth = 20;
            const legendHeight = height;
            const legendScale = d3.scaleLinear()
                .domain([d3.min(allValues), d3.max(allValues)])
                .range([legendHeight, 0]);

            const legendAxis = d3.axisRight(legendScale).ticks(5);

            const defs = svg.append('defs');
            const linearGradient = defs.append('linearGradient')
                .attr('id', 'legend-gradient')
                .attr('x1', '0%')
                .attr('x2', '0%')
                .attr('y1', '100%')
                .attr('y2', '0%');

            linearGradient.selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .enter().append('stop')
                .attr('offset', d => `${d * 100}%`)
                .attr('stop-color', d => colorScale(d3.min(allValues) + d * (d3.max(allValues) - d3.min(allValues))));

            svg.append('rect')
                .attr('x', width + 20)
                .attr('y', 0)
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)');

            svg.append('g')
                .attr('transform', `translate(${width + 40}, 0)`)
                .call(legendAxis);
        }

        function drawSpeedupChart() {
            const container = d3.select('#speedup-chart');
            container.selectAll('*').remove();

            // Calculate speedup for matching workloads
            const speedupData = [];
            const workloads = [...new Set(filteredData.map(d => d.workload))];

            workloads.forEach(workload => {
                const interpreterTest = filteredData.find(d =>
                    d.workload === workload && d.executor === 'interpreter'
                );
                const jitTest = filteredData.find(d =>
                    d.workload === workload && d.executor === 'jit'
                );

                if (interpreterTest && jitTest) {
                    speedupData.push({
                        workload: workload.replace(/_/g, ' '),
                        speedup: jitTest.statistics.throughput / interpreterTest.statistics.throughput,
                        interpreterThroughput: interpreterTest.statistics.throughput,
                        jitThroughput: jitTest.statistics.throughput
                    });
                }
            });

            if (speedupData.length === 0) {
                container.append('div')
                    .style('padding', '50px')
                    .style('text-align', 'center')
                    .style('color', '#999')
                    .text('No comparison data available');
                return;
            }

            // Sort by speedup (highest to lowest)
            speedupData.sort((a, b) => b.speedup - a.speedup);

            const margin = {top: 20, right: 80, bottom: 50, left: 280};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = Math.max(400, speedupData.length * 60);

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const x = d3.scaleLinear()
                .domain([0, d3.max(speedupData, d => d.speedup) * 1.1])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(speedupData.map(d => d.workload))
                .range([0, height])
                .padding(0.2);

            // Baseline line at 1x
            const baseline1x = x(1);
            svg.append('line')
                .attr('x1', baseline1x)
                .attr('x2', baseline1x)
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#999')
                .attr('stroke-dasharray', '4')
                .attr('stroke-width', 2);

            // Bars
            svg.selectAll('.bar')
                .data(speedupData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.workload))
                .attr('width', d => x(d.speedup))
                .attr('height', y.bandwidth())
                .attr('fill', d => d.speedup > 1 ? colors.jit : colors.interpreter)
                .attr('rx', 4)
                .attr('opacity', 0.85)
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke', '#333').attr('stroke-width', 2);
                    showTooltip(event, d, 'speedup');
                })
                .on('mouseout', function() {
                    d3.select(this).attr('opacity', 0.85).attr('stroke', 'none');
                    hideTooltip();
                });

            // Value labels on bars
            svg.selectAll('.value-label')
                .data(speedupData)
                .enter().append('text')
                .attr('class', 'value-label')
                .attr('x', d => x(d.speedup) + 5)
                .attr('y', d => y(d.workload) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#2d3748')
                .text(d => `${d.speedup.toFixed(2)}x`);

            // Y axis (labels)
            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '13px')
                .style('font-weight', '500');

            // X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .style('text-anchor', 'middle')
                .style('font-size', '13px')
                .style('font-weight', '600')
                .style('fill', '#4a5568')
                .text('Speedup (JIT/Interpreter)');
        }

        function drawTrendsChart() {
            const container = d3.select('#trends-chart');
            container.selectAll('*').remove();

            if (!historyData || historyData.length === 0) {
                container.append('div')
                    .style('padding', '50px')
                    .style('text-align', 'center')
                    .style('color', '#999')
                    .text('No historical data available. Run benchmarks over time to see trends.');
                return;
            }

            const margin = {top: 20, right: 150, bottom: 80, left: 80};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Flatten history data and parse timestamps
            const allPoints = [];
            historyData.forEach(snapshot => {
                snapshot.benchmarks.forEach(bench => {
                    allPoints.push({
                        name: bench.name,
                        timestamp: new Date(bench.timestamp),
                        mean_ns: bench.mean_ns,
                        median_ns: bench.median_ns
                    });
                });
            });

            // Group by benchmark name
            const benchmarkNames = [...new Set(allPoints.map(p => p.name))];
            const colorScale = d3.scaleOrdinal()
                .domain(benchmarkNames)
                .range(d3.schemeCategory10);

            // Create scales
            const x = d3.scaleTime()
                .domain(d3.extent(allPoints, d => d.timestamp))
                .range([0, width]);

            // Use log scale for better visibility of varying values
            const minVal = d3.min(allPoints, d => d.mean_ns);
            const maxVal = d3.max(allPoints, d => d.mean_ns);
            const y = d3.scaleLog()
                .domain([Math.max(0.1, minVal * 0.8), maxVal * 1.2])
                .range([height, 0]);

            // Draw lines for each benchmark
            benchmarkNames.forEach(name => {
                const benchData = allPoints
                    .filter(p => p.name === name)
                    .sort((a, b) => a.timestamp - b.timestamp);

                if (benchData.length === 0) return;

                const line = d3.line()
                    .x(d => x(d.timestamp))
                    .y(d => y(d.mean_ns))
                    .curve(d3.curveMonotoneX);

                // Draw line
                svg.append('path')
                    .datum(benchData)
                    .attr('fill', 'none')
                    .attr('stroke', colorScale(name))
                    .attr('stroke-width', 2)
                    .attr('d', line)
                    .attr('opacity', 0.8)
                    .on('mouseover', function() {
                        d3.select(this).attr('stroke-width', 4).attr('opacity', 1);
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('stroke-width', 2).attr('opacity', 0.8);
                    });

                // Draw points
                svg.selectAll(`.point-${name.replace(/[^a-zA-Z0-9]/g, '_')}`)
                    .data(benchData)
                    .enter().append('circle')
                    .attr('cx', d => x(d.timestamp))
                    .attr('cy', d => y(d.mean_ns))
                    .attr('r', 4)
                    .attr('fill', colorScale(name))
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2)
                    .on('mouseover', function(event, d) {
                        d3.select(this).attr('r', 6);
                        showTooltip(event, {
                            name: d.name,
                            timestamp: d.timestamp.toLocaleString(),
                            mean_ns: d.mean_ns.toFixed(2),
                            median_ns: d.median_ns.toFixed(2)
                        }, 'trends');
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('r', 4);
                        hideTooltip();
                    });
            });

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x)
                    .ticks(5)
                    .tickFormat(d3.timeFormat('%m/%d %H:%M')))
                .selectAll('text')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .style('font-size', '10px');

            svg.append('g')
                .call(d3.axisLeft(y).tickFormat(d => d.toFixed(0)));

            // Axis labels
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Mean Latency (ns)');

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .text('Timestamp');

            // Legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width + 20}, 0)`);

            benchmarkNames.forEach((name, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);

                legendRow.append('rect')
                    .attr('width', 15)
                    .attr('height', 15)
                    .attr('fill', colorScale(name));

                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 12)
                    .style('font-size', '11px')
                    .text(name.substring(0, 20) + (name.length > 20 ? '...' : ''));
            });
        }

        function showTooltip(event, data, type = 'default') {
            const tooltip = d3.select('#tooltip');

            let content = '';
            if (type === 'default') {
                content = `
                    <strong>${data.name}</strong><br/>
                    Executor: ${data.executor}<br/>
                    Workload: ${data.workload}<br/>
                    Throughput: ${data.statistics.throughput.toFixed(0)} ops/sec<br/>
                    p50: ${data.statistics.p50.toFixed(2)} µs<br/>
                    p99: ${data.statistics.p99.toFixed(2)} µs
                `;
            } else if (type === 'throughput') {
                content = `
                    <strong>${data.name}</strong><br/>
                    Throughput: ${data.statistics.throughput.toFixed(0)} ops/sec<br/>
                    Sample Rate: ${data.statistics.sample_rate.toFixed(0)} samples/sec
                `;
            } else if (type === 'cache') {
                content = `
                    <strong>${data.label}</strong><br/>
                    ${data.value.toFixed(2)}%
                `;
            } else if (type === 'heatmap') {
                content = `
                    <strong>${data.test}</strong><br/>
                    ${data.metric}: ${data.value} µs
                `;
            } else if (type === 'speedup') {
                content = `
                    <strong>${data.workload}</strong><br/>
                    Speedup: ${data.speedup.toFixed(2)}x<br/>
                    Interpreter: ${data.interpreterThroughput.toFixed(0)} ops/sec<br/>
                    JIT: ${data.jitThroughput.toFixed(0)} ops/sec
                `;
            } else if (type === 'trends') {
                content = `
                    <strong>${data.name}</strong><br/>
                    Time: ${data.timestamp}<br/>
                    Mean: ${data.mean_ns} ns<br/>
                    Median: ${data.median_ns} ns
                `;
            }

            tooltip
                .style('opacity', 1)
                .html(content)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        }

        function hideTooltip() {
            d3.select('#tooltip').style('opacity', 0);
        }

        function exportData() {
            const dataStr = JSON.stringify(perfData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `perftest-export-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Initialize
        loadData();
    </script>
</body>
</html>
